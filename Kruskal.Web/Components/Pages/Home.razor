    @inject NavigationManager NavManager
    @page "/"

    <style>
        body{
        background-color: #FEFAF6;
    }
</style>
  
<PageTitle>Home</PageTitle>
<nav><h1>Kruskal's Algorithm</h1></nav>
<div id="full-container">
<div id="main-container">
    <form id="matrix-form" @onsubmit="SubmitForm">
        <div id="matrix-form-inputs">
            <table>
                <tr>
                    <th></th>
                    @foreach (var label in rowLabels)
                    {
                        <th>@label</th>
                    }
                </tr>
                @for (int i = 0; i < 4; i++)
                {
                    <tr>
                        <td><strong>@rowLabels[i]</strong></td>
                        @for (int j = 0; j < 4; j++)
                        {
                            var index = i * 4 + j; // Calculate the index
                            <td>
                                <input type="number" @bind="@matrixValues[index]" />
                            </td>
                        }
                    </tr>
                }
            </table>
        </div>
        <button type="submit" class="btn btn-primary">Build Tree</button>
    </form>
    <div id="initial-graph-div">
            <h3>Initial Graph</h3>
        @if (formSubmitted)
        {
            <div class="svg-container">

            <svg width="400" height="400">

                @foreach (var edge in startingEdges)
                {
                    var sourcePosition = edge.Source.Location;
                    var destinationPosition = edge.Destination.Location;

                    <line x1="@sourcePosition.x" y1="@sourcePosition.y"
                          x2="@destinationPosition.x" y2="@destinationPosition.y"
                          style="stroke:black; stroke-width:2" />
                    <text>
                        <text x="@(((sourcePosition.x + destinationPosition.x)/2)-6)" y="@(((sourcePosition.y + destinationPosition.y)/2)-6)">@edge.Weight</text>
                    </text>
                }

                <!-- Draw vertices -->
                @foreach (var vertex in vertices)
                {
                    <circle cx="@vertex.Location.x" cy="@vertex.Location.y" r="20" fill="#102C57" />
                    <text>
                        <text fill="#FEFAF6" x="@((vertex.Location.x -6))" y="@((vertex.Location.y + 6))">@vertex.Name </text>
                    </text>
                }


            </svg>
            </div>
            <button id="kruskal-btn" @onclick="RunKruskal">Run Kruskal's Algorithm</button>
        }
    </div>
    <div id="minimal-graph-div">
        <h3>Minimal Spanning Tree</h3>
        @if(ranKruskal)
        {
            <div class="svg-container">

                <svg width="400" height="400">

                    @foreach (var edge in minimalEdges)
                    {
                        var sourcePosition = edge.Source.Location;
                        var destinationPosition = edge.Destination.Location;

                        <line x1="@sourcePosition.x" y1="@sourcePosition.y"
                              x2="@destinationPosition.x" y2="@destinationPosition.y"
                              style="stroke:black; stroke-width:2" />
                        <text>
                            <text x="@(((sourcePosition.x + destinationPosition.x)/2)-6)" y="@(((sourcePosition.y + destinationPosition.y)/2)-6)">@edge.Weight</text>
                        </text>
                    }

                    <!-- Draw vertices -->
                    @foreach (var vertex in vertices)
                    {
                        <circle cx="@vertex.Location.x" cy="@vertex.Location.y" r="20" fill="#102C57" />
                        <text>
                            <text fill="#FEFAF6" x="@((vertex.Location.x -6))" y="@((vertex.Location.y + 6))">@vertex.Name </text>
                        </text>
                    }


                </svg>
            </div>

            <span id="cost-span"><strong>Total Cost:</strong> @totalCost</span>
        }


    </div>
</div>

    <button id="reset-button" @onclick="ResetForm">Reset</button>
</div>

@code {
    private Kruskal kruskal = new();
    private int[] matrixValues = new int[16]; // Use a flat array
    private char[] rowLabels = new[] { 'A', 'B', 'C', 'D' };
    private Vertex[] vertices = new[] { new Vertex('A'), new Vertex('B'), new Vertex('C'), new Vertex('D') };
    private int totalCost;
    private List<Edge> startingEdges = new List<Edge>();
    private List<Edge> minimalEdges = new List<Edge>();
    private Random random = new Random();
    private bool formSubmitted = false;
    private bool ranKruskal = false;



    protected override void OnInitialized()
    {
        // Initialize matrixValues to all zeroes
        Array.Fill(matrixValues, 0);

        vertices[0].Location = (50, 50);   // Vertex 'A'
        vertices[1].Location = (200, 50);  // Vertex 'B'
        vertices[2].Location = (50, 200);  // Vertex 'C'
        vertices[3].Location = (200, 200); // Vertex 'D'
    }


    private void SubmitForm()
    {
        formSubmitted = true;

        // Clear startingEdges before populating
        startingEdges.Clear();

        // Populate startingEdges based on matrixValues
        for (int i = 0; i < 4; i++)
        {
            for (int j = 0; j < 4; j++)
            {
                int index = i * 4 + j; // Calculate the index
                int value = matrixValues[index];

                if (value != 0)
                {
                    Vertex src = vertices[j];
                    Vertex dest = vertices[i];

                    src.Location = GetVertexPosition(src);
                    dest.Location = GetVertexPosition(dest);

                    startingEdges.Add(new Edge(value, src, dest));
                }
            }
        }
    }

    private void ResetForm()
    {
        NavManager.NavigateTo(NavManager.Uri, forceLoad: true);   
    }

    public void RunKruskal()
    {
        minimalEdges = kruskal.FindMinimumSpanningTree(startingEdges, out totalCost);
        ranKruskal = true;
        StateHasChanged();
    }

    private (int x, int y) GetVertexPosition(Vertex vertex)
    {
        int x = Array.IndexOf(rowLabels, vertex.Name) * 100 + 50;
        int y = random.Next(100, 300);

        // implement validation to keep vertices away from each others' x and y axes

        return (x, y);
    }

    private (int x, int y) GetVertexPositionValidated(Vertex vertex)
    {
        int x;
        int y;
        int minDistance = 40;

        bool tooClose = false;

        do
        {
            x = Array.IndexOf(rowLabels, vertex.Name) * 100 + 50;
            y = random.Next(100, 300);

            tooClose = false;

            foreach (var v in vertices)
            {
                // Calculate the distance between the new vertex and existing vertices
                double distanceX = Math.Abs(x - v.Location.x);
                double distanceY = Math.Abs(y - v.Location.y);

                // Check if the new vertex is too close in both x and y directions
                if (distanceX < minDistance || distanceY < minDistance)
                {
                    tooClose = true;
                    break;
                }
            }
        } while (tooClose);

        return (x, y);
    }
}
